<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Покер WebApp — GTO пресеты, действия оппов, эквити</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; background: #0b1220; }
    #root { max-width: 420px; margin: 0 auto; }
    .noselect { -webkit-user-select:none; -moz-user-select:none; user-select:none; }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body class="text-slate-100">
  <div id="root"></div>

  <script type="module">
    // Telegram init (без токенов)
    const tg = window.Telegram?.WebApp; if (tg) { tg.ready(); tg.expand(); }

    // pokersolver (ESM)
    const PokerSolverNS = await import('https://cdn.jsdelivr.net/npm/pokersolver/+esm');
    const Hand = (PokerSolverNS && (PokerSolverNS.Hand || (PokerSolverNS.default && PokerSolverNS.default.Hand))) || null;

    const { useState, useMemo } = React;

    // ===== Карты =====
    const SUITS = ["s","h","d","c"];
    const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
    const RVAL  = Object.fromEntries(RANKS.map((r,i)=>[r,14-i]));
    function makeDeck(){ const d=[]; for(const r of RANKS) for(const s of SUITS) d.push(r+s); return d; }
    function removeCards(deck, used){ const set=new Set(used); return deck.filter(c=>!set.has(c)); }
    function shuffle(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
    function cardLabel(cs){ const r=cs[0], s=cs[1]; const suit={s:"♠",h:"♥",d:"♦",c:"♣"}; const red=(s==="h"||s==="d"); return React.createElement("span",{className:red?"text-rose-400":""}, r, suit[s]); }

    // ===== Хелперы комбинаций =====
    const HAND_ORDER=["Старшая карта","Пара","Две пары","Сет","Стрит","Флеш","Фул-хаус","Каре","Стрит-флеш"];
    function winners(list){ if(!Hand) return []; try { return Hand.winners(list); } catch { return []; } }
    function solveHand(cards,game){ if(!Hand) return null; try { return game==="omaha"?Hand.solve(cards,"omaha"):Hand.solve(cards);} catch { return null; } }
    function handTypeNameRu(h){ if(!h) return "Старшая карта"; const raw=(h.name||h.descr||(h.toString?h.toString():"")).toLowerCase(); const map=[["straight flush","Стрит-флеш"],["four of a kind","Каре"],["full house","Фул-хаус"],["flush","Флеш"],["straight","Стрит"],["three of a kind","Сет"],["two pair","Две пары"],["pair","Пара"]]; for(const [k,v] of map) if(raw.includes(k)) return v; return "Старшая карта"; }

    // ===== Позиции и пресеты диапазонов (169-комбо) =====
    const POS = [
      {key:"BTN",label:"BTN (дилер)", tight:0.55},
      {key:"CO", label:"CO", tight:0.48},
      {key:"MP", label:"MP", tight:0.40},
      {key:"UTG",label:"UTG",tight:0.34},
      {key:"SB", label:"SB", tight:0.50},
      {key:"BB", label:"BB", tight:0.58},
    ];

    // 169-канон
    function canon169(a,b,suited){ const i1=RANKS.indexOf(a), i2=RANKS.indexOf(b); const hi = i1<=i2? a : b; const lo = i1<=i2? b : a; if(a===b) return a+a; return hi+lo+(suited?"s":"o"); }
    function canonFromCards2(c1,c2){ return canon169(c1[0], c2[0], c1[1]===c2[1]); }

    // Парсер короткой нотации (77+, ATs+, KTo+, 22-66, ATs-KQs, T9s и т.п.)
    function expandSpec(spec){
      spec = spec.replace(/\s+/g,'');
      const add = new Set();
      const ranks = RANKS; const ri = (r)=>ranks.indexOf(r);
      function pushPairRange(lo, hi){ const i1 = ri(lo), i2 = ri(hi); for(let i=Math.min(i1,i2); i<=Math.max(i1,i2); i++) add.add(ranks[i]+ranks[i]); }
      function pushNonPairRange(hilo, lohi, suited){ const iH1 = ri(hilo[0]); const iH2 = ri(lohi[0]); const iL1 = ri(hilo[1]); const iL2 = ri(lohi[1]); const hiStart=Math.min(iH1,iH2), hiEnd=Math.max(iH1,iH2); const loStart=Math.min(iL1,iL2), loEnd=Math.max(iL1,iL2); for(let ih=hiStart; ih<=hiEnd; ih++){ for(let il=loStart; il<=loEnd; il++){ if(ih===il) continue; const hi=ranks[ih], lo=ranks[il]; add.add(canon169(hi,lo, suited)); } } }
      for(const part of spec.split(',')){
        if(!part) continue;
        const mPairPlus = part.match(/^([2-9TJQKA])\1\+$/i);
        const mPairDash = part.match(/^([2-9TJQKA])\1-([2-9TJQKA])\2$/i);
        const mPairExact = part.match(/^([2-9TJQKA])\1$/i);
        const mS = part.match(/^([2-9TJQKA])([2-9TJQKA])([so])\+$/i);
        const mSDash = part.match(/^([2-9TJQKA])([2-9TJQKA])([so])\-([2-9TJQKA])([2-9TJQKA])\3$/i);
        const mExact = part.match(/^([2-9TJQKA])([2-9TJQKA])([so])$/i);
        if(mPairPlus){ pushPairRange(mPairPlus[1], 'A'); continue; }
        if(mPairDash){ pushPairRange(mPairDash[1], mPairDash[2]); continue; }
        if(mPairExact){ add.add(mPairExact[1]+mPairExact[1]); continue; }
        if(mS){ const hi=mS[1], lo=mS[2], suited=(mS[3]==='s'); const iHi=ri(hi); const iLoStart=ri(lo); for(let il=iLoStart; il<ranks.length; il++){ if(il===iHi) continue; add.add(canon169(hi, ranks[il], suited)); } continue; }
        if(mSDash){ const hi1=mSDash[1], lo1=mSDash[2], st=mSDash[3]==='s'; const hi2=mSDash[4], lo2=mSDash[5]; pushNonPairRange(hi1+lo1, hi2+lo2, st); continue; }
        if(mExact){ const hi=mExact[1], lo=mExact[2], st=mExact[3]==='s'; add.add(canon169(hi,lo,st)); continue; }
        const mAB = part.match(/^([2-9TJQKA])([2-9TJQKA])$/i);
        if(mAB){ const hi=mAB[1], lo=mAB[2]; if(hi!==lo){ add.add(canon169(hi,lo,true)); add.add(canon169(hi,lo,false)); } else { add.add(hi+hi); } continue; }
      }
      return add; }
    function expandList(list){ const out=new Set(); for(const s of list) for(const x of expandSpec(s)) out.add(x); return out; }

    // Вшитые «GTO‑подобные» пресеты (стартовые)
    const BASE_OPEN_SPEC = {
      UTG: ["77+","ATs+","KQs","KJs+","QJs","JTs","T9s","AJo+","KQo"],
      MP:  ["66+","ATs+","KTs+","QTs+","JTs","T9s","98s","AJo+","KQo"],
      CO:  ["55+","A9s+","K9s+","Q9s+","J9s+","T9s","98s","A8o+","KJo+","QJo"],
      BTN: ["22+","A2s+","K6s+","Q8s+","J8s+","T8s+","97s+","86s+","A2o+","KTo+","QTo+","JTo"],
      SB:  ["55+","A2s+","K7s+","Q9s+","J9s+","T9s","A8o+","KJo+","QJo"],
      BB:  ["55+","A2s+","K7s+","Q9s+","J9s+","T9s","A9o+","KJo+","QJo"],
    };
    const STRONG_SPEC = ["99+","ATs+","KQs","KJs+","QJs","AJo+","KQo"]; // для 3-бета
    const MID_SPEC    = ["22-88","A2s+","K9s+","Q9s+","J9s+","T9s","98s","A9o-AQo","KTo+","QTo+","JTo"]; // для колла
    const WIDE_SPEC   = ["22+","A2s+","K6s+","Q8s+","J8s+","T8s+","97s+","86s+","A2o+","KTo+","QTo+","JTo"]; // для чеков/широких

    const BASE_OPEN = Object.fromEntries(Object.entries(BASE_OPEN_SPEC).map(([k,v])=>[k, expandList(v)]));
    const STRONG = expandList(STRONG_SPEC);
    const MID    = expandList(MID_SPEC);
    const WIDE   = expandList(WIDE_SPEC);

    function intersect(A,B){ const out=new Set(); for(const x of A) if(B.has(x)) out.add(x); return out; }
    function rangeByAction(posKey, action){
      const base = new Set(BASE_OPEN[posKey] || []);
      switch(action){
        case 'open': return base;
        case 'reraise': return intersect(base, STRONG);
        case 'call': return intersect(base, MID);
        case 'check': return intersect(base, WIDE);
        case 'bet': return intersect(base, STRONG);
        case 'raise': return intersect(base, STRONG);
        case 'fold': return new Set();
        default: return new Set();
      }
    }
    function refinePostflop(canonSet, streetAction){
      if(!canonSet || canonSet.size===0) return new Set();
      switch(streetAction){
        case 'bet':
        case 'raise': return intersect(canonSet, STRONG);
        case 'call': return intersect(canonSet, MID);
        case 'check': return intersect(canonSet, WIDE);
        case 'fold': return new Set();
        default: return canonSet;
      }
    }
    function rangeUpToStage(posKey, actions, stage){
      let s = rangeByAction(posKey, actions?.preflop || 'fold');
      if(stage==='preflop') return s;
      s = refinePostflop(s, actions?.flop || 'check');
      if(s.size===0 || stage==='flop') return s;
      s = refinePostflop(s, actions?.turn || 'check');
      if(s.size===0 || stage==='turn') return s;
      s = refinePostflop(s, actions?.river || 'check');
      return s;
    }
    function holdemCanonRange(posKey, action){ return Array.from(rangeByAction(posKey, action)); }
    function holdemCanonRangeUpToStage(posKey, actions, stage){ return Array.from(rangeUpToStage(posKey, actions, stage)); }

    // ===== Эвристики (оценка силы руки) и acceptByRange для Омахи =====
    function scoreHoldem2(c1,c2){
      const r1=RVAL[c1[0]], r2=RVAL[c2[0]]; const suited=(c1[1]===c2[1]); const pair=(c1[0]===c2[0]);
      const gap=Math.abs(r1-r2); const hi=(r1>=13)+(r2>=13);
      const base=Math.max(r1,r2)+Math.min(r1,r2)*0.6; return base+(pair?6:0)+(suited?2:0)-gap*0.6+hi*1.5;
    }
    function scoreOmaha4(cs){ let ranks=cs.map(c=>RVAL[c[0]]).sort((a,b)=>b-a); let base=ranks[0]*1.0+ranks[1]*0.8+ranks[2]*0.5+ranks[3]*0.3; const suits=cs.map(c=>c[1]); const suitCounts=Object.values(suits.reduce((m,s)=>(m[s]=(m[s]||0)+1,m),{})); base+=suitCounts.filter(n=>n>=2).length*1.8; ranks.sort((a,b)=>a-b); let gaps=0; for(let i=1;i<ranks.length;i++) gaps+=Math.max(0,ranks[i]-ranks[i-1]-1); base-=gaps*0.2; const counts=cs.reduce((m,c)=>(m[c[0]]=(m[c[0]]||0)+1,m),{}); if((counts.A||0)>=2) base+=3; if((counts.K||0)>=2) base+=1.5; return base; }
    const ACTION_T = { open:0.64, call:0.52, reraise:0.72, check:0.50 };
    function normalizeScore(s){ return 1/(1+Math.exp(-(s-14)/2.5)); }
    function acceptByRange(game, cards, posKey, action){ const pos=POS.find(p=>p.key===posKey)||POS[0]; const s=game==="omaha"?scoreOmaha4(cards):(cards.length===2?scoreHoldem2(cards[0],cards[1]):0); const z=normalizeScore(s); const need=Math.min(0.95,Math.max(0.05, ACTION_T[action||'open'] * (pos.tight+0.5)/1.0)); return z>=need; }

    // ===== Симулятор эквити с учётом действий/позиции =====
    function simEquity({ game, hero, board, seats, iters=1600 }){
      const deck0 = removeCards(makeDeck(), [...hero, ...board]);
      const takePerVillain = game==="omaha"?4:2; const stageStr = (board.length===0?'preflop':board.length===3?'flop':board.length===4?'turn':'river');
      const oppSeats=seats.map(s=>({ id:s.id, pos:s.pos, actions:s.actions }));
      let wins=0, ties=0; const dist=Object.fromEntries(HAND_ORDER.map(k=>[k,0])); const need=5-board.length;

      function dealSeatHands(pool){
        let d=pool.slice(); const hands=[];
        for(const seat of oppSeats){
          // folded so far?
          const folded = (seat.actions?.preflop==='fold') || (stageStr!=='preflop' && seat.actions?.flop==='fold') || (stageStr==='river' && seat.actions?.river==='fold') || (stageStr==='turn' && seat.actions?.turn==='fold');
          if(folded) continue;

          let ok=null; let tries=0;
          if(game==='holdem'){
            const allowed = new Set(holdemCanonRangeUpToStage(seat.pos, seat.actions, stageStr));
            while(tries<500 && d.length>=2){ const c1=d[0], c2=d[1]; d=d.slice(2); const lab=canonFromCards2(c1,c2); if(allowed.size===0 || allowed.has(lab)){ ok=[c1,c2]; break; } tries++; }
          } else {
            while(tries<200 && d.length>=4){ const pick=d.slice(0,4); d=d.slice(4); if(acceptByRange('omaha', pick, seat.pos, seat.actions?.preflop||'open')){ ok=pick; break; } tries++; }
          }
          if(!ok){ const need=takePerVillain; if(d.length<need) break; ok=d.slice(0,need); d=d.slice(need); }
          hands.push(ok);
        }
        return {hands};
      }

      function oneTrial(b){
        let d=shuffle(deck0);
        d=removeCards(d, b.filter(x=>!board.includes(x)));
        const {hands:vHands}=dealSeatHands(d);
        const heroSolved=solveHand([...hero,...b],game); if(!heroSolved) return;
        const villSolved=vHands.map(v=>solveHand([...v,...b],game)).filter(Boolean);
        const ws=winners([heroSolved,...villSolved]); if(!ws||ws.length===0) return;
        if(ws.includes(heroSolved)){ if(ws.length>1) ties++; else wins++; }
        const key=handTypeNameRu(heroSolved); dist[key]=(dist[key]||0)+1;
      }

      if(need<=1){ const rem=deck0.slice(); const variants=need===0?[board]:rem.map(c=>[...board,c]); const reps=Math.max(1,Math.floor(iters/variants.length)); for(const b of variants){ for(let t=0;t<reps;t++) oneTrial(b);} } else { for(let t=0;t<iters;t++){ let d=shuffle(deck0); const add=5-board.length; const extra=d.slice(0,add); oneTrial(board.concat(extra)); } }
      const total=Object.values(dist).reduce((a,b)=>a+b,0)||1; return {equity:(wins+0.5*ties)/total, probs:Object.fromEntries(HAND_ORDER.map(k=>[k,(dist[k]||0)/total])), tie:ties/total};
    }

    // Текущая лучшая и ауты по типам на следующей карте
    function currentBest({ game, hero, board }){ if(board.length+hero.length<5) return null; return solveHand([...hero,...board], game); }
    function computeOutsByTypeNextCard({game,hero,board}){ const map=Object.fromEntries(HAND_ORDER.map(k=>[k,0])); const needs=board.length===3||board.length===4; if(!needs) return {map}; const deck=removeCards(makeDeck(),[...hero,...board]); for(const c of deck){ const solved=solveHand([...hero,...board,c],game); const t=handTypeNameRu(solved); map[t]=(map[t]||0)+1; } return {map}; }

    // ===== UI =====
    function Pill({children}){ return React.createElement("span",{className:"px-2 py-0.5 rounded-full bg-slate-800 text-slate-200 text-xs font-medium"},children); }
    function CardPicker({disabled,taken,currentCount,limit,onPick,title}){ const deck=makeDeck(); const takenSet=new Set(taken); const canPick=c=>!takenSet.has(c)&&currentCount<limit&&!disabled; return React.createElement("div",{className:"space-y-1"}, title?React.createElement("div",{className:"text-xs text-slate-400"},title):null, React.createElement("div",{className:"grid grid-cols-8 gap-1"}, ...deck.map(c=>React.createElement("button",{key:c,onClick:()=>canPick(c)?onPick(c):null,disabled:!!disabled||takenSet.has(c)||currentCount>=limit,className:"noselect border border-slate-700 rounded py-0.5 text-center text-xs "+(takenSet.has(c)?"opacity-30 cursor-not-allowed":currentCount<limit&&!disabled?"bg-slate-900":"bg-slate-800")}, cardLabel(c)))) ); }
    function GridCards({title,cards}){ return React.createElement("div",{className:"bg-slate-900 rounded-lg shadow p-2 border border-slate-700"}, title?React.createElement("div",{className:"text-xs text-slate-400 mb-2"},title):null, React.createElement("div",{className:"flex flex-wrap gap-2 text-lg"}, ...cards.map(c=>React.createElement("div",{key:c,className:"px-2 py-1 rounded border border-slate-700 bg-slate-800"},cardLabel(c)))) ); }

    const DEFAULT_SEATS = [
      { id:1, pos:"UTG", actions:{ preflop:"open", flop:"check", turn:"check", river:"check" } },
      { id:2, pos:"MP",  actions:{ preflop:"call", flop:"call",  turn:"call",  river:"call" } },
      { id:3, pos:"CO",  actions:{ preflop:"fold", flop:"fold",  turn:"fold",  river:"fold" } },
      { id:4, pos:"BTN", actions:{ preflop:"call", flop:"call",  turn:"call",  river:"call" } },
      { id:5, pos:"SB",  actions:{ preflop:"check",flop:"check", turn:"check", river:"check" } },
    ];
    function SeatRow({ seat, stage, onChange, disabled }){
      const st = stage;
      const act = seat.actions?.[st] || (st==='preflop'?'fold':'check');
      function setAct(v){ onChange({...seat, actions:{...seat.actions, [st]: v}}); }
      return React.createElement(
        "div",
        { className: "flex items-center justify-between gap-2 p-2 rounded border border-slate-700 " + (disabled?"opacity-60":"bg-slate-900") },
        React.createElement("div",{className:"text-xs"}, `Оппонент #${seat.id}`),
        React.createElement(
          "div",
          { className: "flex items-center gap-1" },
          React.createElement(
            "select",
            { disabled, className:"px-2 py-1 bg-slate-800 border border-slate-700 rounded text-xs", value:seat.pos, onChange:e=>onChange({...seat,pos:e.target.value}) },
            ...POS.map(p=>React.createElement("option",{key:p.key,value:p.key},p.key))
          ),
          (st==='preflop'
            ? React.createElement(
                "select",
                { disabled, className:"px-2 py-1 bg-slate-800 border border-slate-700 rounded text-xs", value:act, onChange:e=>setAct(e.target.value) },
                React.createElement("option",{value:"open"},"рейз"),
                React.createElement("option",{value:"call"},"колл"),
                React.createElement("option",{value:"reraise"},"3-бет"),
                React.createElement("option",{value:"check"},"чек"),
                React.createElement("option",{value:"fold"},"фолд")
              )
            : React.createElement(
                "select",
                { disabled, className:"px-2 py-1 bg-slate-800 border border-slate-700 rounded text-xs", value:act, onChange:e=>setAct(e.target.value) },
                React.createElement("option",{value:"bet"},"бет"),
                React.createElement("option",{value:"check"},"чек"),
                React.createElement("option",{value:"call"},"колл"),
                React.createElement("option",{value:"raise"},"рейз"),
                React.createElement("option",{value:"fold"},"фолд")
              )
          )
        )
      );
    }

    // ===== Приложение =====
    function heroNeed(game){ return game==="omaha"?4:2; }
    const STAGES=["preflop","flop","turn","river"]; function nextStage(s){ const i=STAGES.indexOf(s); return (i<0||i===STAGES.length-1)? s : STAGES[i+1]; }

    function App(){
      const [view,setView]=useState("home");
      const [game,setGame]=useState("holdem");
      const [stage,setStage]=useState("preflop");
      const [phase,setPhase]=useState("pick"); // "actions" | "pick"
      const [hero,setHero]=useState([]);
      const [board,setBoard]=useState([]);
      const [seats,setSeats]=useState(DEFAULT_SEATS);
      const [showRanges,setShowRanges]=useState(false);

      const needHero = heroNeed(game);

      const equityData = useMemo(()=>{ if(stage==="preflop") return null; if(hero.length<needHero) return null; return simEquity({ game, hero, board, seats, iters: 1600 }); }, [game, hero, board, stage, seats]);
      const bestNow = useMemo(()=> stage==="preflop"?null:currentBest({game,hero,board}), [game,hero,board,stage]);
      const outsByType = useMemo(()=> computeOutsByTypeNextCard({game,hero,board}), [game,hero,board]);

      function resetHand(){ setHero([]); setBoard([]); setStage("preflop"); setPhase("pick"); }
      function onPickHero(c){ if(hero.includes(c)||hero.length>=needHero) return; const next=[...hero,c]; setHero(next); }
      function onPickBoard(c){ if(board.includes(c)) return; const lim = stage==="flop"?3: stage==="turn"?4: 5; const next=[...board,c]; setBoard(next); }

      function proceedAfterActions(){ if(stage==="preflop"){ setStage("flop"); setPhase("pick"); } else if(stage==="flop"){ setStage("turn"); setPhase("pick"); } else if(stage==="turn"){ setStage("river"); setPhase("pick"); } }
      function openActionsPhase(){ setPhase("actions"); }

      const heroReady = hero.length>=needHero;
      const pickedEnough = (stage==="flop" && board.length>=3) || (stage==="turn" && board.length>=4) || (stage==="river" && board.length>=5);

      // HOME
      if(view==="home"){
        return React.createElement("div",{className:"w-full min-h-screen p-4"},
          React.createElement("div",{className:"max-w-sm mx-auto mt-10 space-y-4 text-center"},
            React.createElement("h1",{className:"text-2xl font-bold"},"Выберите покер"),
            React.createElement("div",{className:"grid grid-cols-1 gap-3"},
              React.createElement("button",{className:"p-4 rounded-xl border border-slate-700 bg-slate-900 shadow text-lg",onClick:()=>{setGame("holdem"); resetHand(); setView("table");}},"Холдем (2)"),
              React.createElement("button",{className:"p-4 rounded-xl border border-slate-700 bg-slate-900 shadow text-lg",onClick:()=>{setGame("omaha"); resetHand(); setView("table");}},"Омаха (4)")
            )
          )
        );
      }

      // TABLE
      return React.createElement("div",{className:"w-full min-h-screen p-2"},
        React.createElement("div",{className:"space-y-3 max-w-sm mx-auto"},
          // header
          React.createElement("div",{className:"flex items-center justify-between"},
            React.createElement("div",{className:"text-xs text-slate-300"},"Игра: ", game==="holdem"?"Холдем":"Омаха", " · ", (stage==="preflop"?"Префлоп":stage==="flop"?"Флоп":stage==="turn"?"Тёрн":"Ривер"), " · ", (phase==="actions"?"Действия оппонентов":"Выбор карт")),
            React.createElement("div",{className:"flex items-center gap-2"},
              React.createElement("button",{className:"text-xs underline",onClick:()=>setView("home")},"← Тип игры"),
              React.createElement("button",{className:"text-xs underline",onClick:resetHand},"Новая раздача")
            )
          ),

          // seats + ranges button
          React.createElement("div",{className:"bg-slate-900 rounded-lg shadow p-2 border border-slate-700 space-y-2"},
            React.createElement("div",{className:"text-xs text-slate-300 mb-1"},"Стол 6-max — действия оппонентов на этой улице"),
            ...DEFAULT_SEATS.map((def)=>{ const seat = seats.find(s=>s.id===def.id)||def; return React.createElement(SeatRow,{ key:seat.id, seat, stage, disabled: phase!=="actions", onChange:(s)=> setSeats(prev=>prev.map(x=>x.id===s.id?s:x)) }); }),
            React.createElement("div",{className:"flex gap-2"},
              React.createElement("button",{className:"px-3 py-1 rounded border border-slate-700 text-xs", onClick:()=>setShowRanges(true)},"Показать диапазоны (ГТО)"),
              (phase==="actions" && heroReady && (stage!=="river")) && React.createElement("button",{className:"px-3 py-1 rounded border border-slate-700 bg-emerald-700 text-white text-xs", onClick:proceedAfterActions}, stage==="preflop"?"Открыть флоп":"Открыть "+(stage==="flop"?"тёрн":"ривер")),
              (phase!=="actions") && React.createElement("span",{className:"text-[11px] text-slate-400"},"Сначала выберите карты улицы — затем задайте действия оппонентов.")
            )
          ),

          // hero + board visuals
          (hero.length>0) && React.createElement(GridCards,{title:"Ваши карманные",cards:hero}),
          (board.length>0) && React.createElement(GridCards,{title:"Борд",cards:board}),

          // equity box (без range-vs-range)
          (stage!=="preflop") && React.createElement("div",{className:"bg-slate-900 rounded-lg shadow p-2 space-y-1 text-center border border-slate-700"},
            React.createElement(Pill,null,"Комбинация: ", bestNow?handTypeNameRu(bestNow):"—"),
            equityData && React.createElement(Pill,null, "Эквити: ", (equityData.equity*100).toFixed(1), "%"),
            React.createElement("div",{className:"grid grid-cols-2 gap-1 text-xs mt-1"},
              ...HAND_ORDER.map(k=>{ const outsK=(outsByType.map?.[k]||0); return React.createElement("div",{key:k,className:"flex items-center justify-between border border-slate-700 rounded px-2 py-1 bg-slate-800"}, React.createElement("span",null,k), React.createElement("div",{className:"text-right"}, React.createElement("div",{className:"font-semibold"}, equityData?((equityData.probs[k]*100).toFixed(1)+"%"):"—"), React.createElement("div",{className:"text-[11px] text-slate-400"},"ауты: ", outsK))); })
            )
          ),

          // единый пикер
          (phase==="pick") && React.createElement(
            CardPicker,
            {
              title: (stage==="preflop"?`Карманные карты (${hero.length}/${needHero})` : stage==="flop"?"Выберите флоп (3 карты)": stage==="turn"?"Выберите тёрн (1 карта)": stage==="river"?"Выберите ривер (1 карта)":"Борд выбран"),
              disabled: (stage==="preflop"? false : (stage==="flop"&&board.length>=3)||(stage==="turn"&&board.length>=4)||(stage==="river"&&board.length>=5)),
              taken: [...hero, ...board],
              currentCount: (stage==="preflop"? hero.length : board.length),
              limit: (stage==="preflop"? needHero : (stage==="flop"?3: stage==="turn"?4: stage==="river"?5:0)),
              onPick: (stage==="preflop"? onPickHero : onPickBoard)
            }
          ),

          // кнопки
          React.createElement("div",{className:"flex flex-wrap gap-2 justify-center"},
            React.createElement("button",{className:"px-3 py-1 rounded border border-slate-700 text-xs bg-slate-900", onClick:resetHand},"Сброс"),
            (stage==="preflop" && heroReady && phase==="pick") && React.createElement("button",{className:"px-3 py-1 rounded border border-slate-700 bg-amber-700 text-white text-xs", onClick:()=>setPhase("actions")},"К действиям префлопа"),
            (stage!=="preflop" && phase==="pick" && pickedEnough) && React.createElement("button",{className:"px-3 py-1 rounded border border-slate-700 bg-amber-700 text-white text-xs", onClick:openActionsPhase},"К действиям на "+(stage==="flop"?"флопе":stage==="turn"?"тёрне":"ривере"))
          ),

          // Модалка диапазонов (показывает пресеты 169-комбо)
          (showRanges) && React.createElement("div",{className:"fixed inset-0 bg-black/60 flex items-end sm:items-center justify-center p-3"},
            React.createElement("div",{className:"w-full max-w-sm bg-slate-900 border border-slate-700 rounded-xl p-3 space-y-2"},
              React.createElement("div",{className:"flex items-center justify-between"},
                React.createElement("div",{className:"text-sm font-medium"},"Диапазоны оппонентов (вшитые пресеты)"),
                React.createElement("button",{className:"text-xs underline", onClick:()=>setShowRanges(false)},"Закрыть")
              ),
              React.createElement("div",{className:"text-[11px] text-slate-400"}, game==="holdem"?"Показаны канонические 169-комбо (AKo, KQs, 77 и т.п.) из вшитых пресетов.":"Омаха: визуализация диапазонов в разработке."),
              ...DEFAULT_SEATS.map((def)=>{ const seat = seats.find(s=>s.id===def.id)||def; const actNow = seat.actions?.[stage] || (stage==='preflop'?'fold':'check'); const opens = (game==="holdem") ? Array.from(rangeUpToStage(seat.pos, seat.actions, stage)) : []; return React.createElement("div",{key:seat.id,className:"border border-slate-700 rounded p-2"}, React.createElement("div",{className:"text-xs mb-1"}, `Оппонент #${seat.id} — ${seat.pos}, действие: ${actNow}`), React.createElement("div",{className:"text-[11px] text-slate-300 break-words"}, opens.length? Array.from(opens).sort().join(', ') : (game==="omaha"?"Скоро: диапазоны Омахи.":"—")) ); })
            )
          )
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
</body>
</html>
